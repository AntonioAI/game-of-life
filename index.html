<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Global Box Sizing */
        html {
            box-sizing: border-box;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }

        /* Basic Reset and Font */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a202c; /* Tailwind gray-900 */
            color: #e2e8f0; /* Tailwind slate-200 */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll on main body */
        }

        /* Main layout: Sidebar and Content Area */
        .app-container {
            display: flex;
            flex-direction: column; /* Stack sidebar above content on small screens */
            flex-grow: 1;
        }

        @media (min-width: 768px) { /* md breakpoint */
            .app-container {
                flex-direction: row; /* Sidebar next to content on larger screens */
            }
        }

        .sidebar {
            width: 100%;
            background-color: #2d3748; /* Tailwind gray-800 */
            padding: 1rem;
            overflow-y: auto;
            border-bottom: 1px solid #4a5568; /* Tailwind gray-700 */
        }

        @media (min-width: 768px) { /* md breakpoint */
            .sidebar {
                width: 320px; /* Fixed width for sidebar */
                min-width: 320px;
                height: 100vh; /* Full viewport height */
                border-right: 1px solid #4a5568; /* Tailwind gray-700 */
                border-bottom: none;
            }
        }
        
        .main-content {
            flex-grow: 1;
            padding: 1rem; /* Padding for spacing around the canvas */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Prevent canvas from causing scrollbars on main content */
            min-height: 0; /* Allow flex item to shrink properly */
        }

        canvas {
            display: block;
            border: 1px solid #4a5568; /* Tailwind gray-700 */
            border-radius: 0.5rem; /* rounded-lg */
        }
        
        /* Panel Styling */
        .panel {
            background-color: #2d3748; /* Tailwind gray-800 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #4a5568; /* Tailwind gray-700 */
        }
        .panel-title {
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            margin-bottom: 0.75rem;
            color: #a0aec0; /* Tailwind gray-400 */
        }

        /* Button Styling */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem; /* rounded-md */
            font-weight: 500; /* font-medium */
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            cursor: pointer;
            border: 1px solid transparent;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
        }
        .btn-primary {
            background-color: #4299e1; /* Tailwind blue-500 */
            color: white;
        }
        .btn-primary:hover {
            background-color: #3182ce; /* Tailwind blue-600 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
        }
        .btn-secondary {
            background-color: #4a5568; /* Tailwind gray-600 */
            color: #e2e8f0; /* Tailwind slate-200 */
        }
        .btn-secondary:hover {
            background-color: #2d3748; /* Tailwind gray-700 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
        }
        .btn-icon {
            padding: 0.5rem;
        }

        /* Input and Slider Styling */
        input[type="range"], input[type="number"], input[type="color"], select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem; /* rounded-md */
            background-color: #1a202c; /* Tailwind gray-900 */
            border: 1px solid #4a5568; /* Tailwind gray-700 */
            color: #e2e8f0; /* Tailwind slate-200 */
            margin-top: 0.25rem;
            margin-bottom: 0.5rem;
            /* box-sizing: border-box; Already handled globally */
        }
        input[type="color"] {
            height: 2.5rem; /* Specific height for color pickers */
            padding: 0.25rem;
        }
        label {
            display: block;
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            color: #a0aec0; /* Tailwind gray-400 */
            margin-bottom: 0.25rem;
        }

        /* Analytics Panel Styling */
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.5rem;
        }
        .analytics-item {
            background-color: #1a202c; /* Tailwind gray-900 */
            padding: 0.5rem;
            border-radius: 0.375rem; /* rounded-md */
            font-size: 0.875rem; /* text-sm */
        }
        .analytics-label {
            font-weight: 600; /* font-semibold */
            color: #718096; /* Tailwind gray-500 */
        }
        .analytics-value {
            color: #e2e8f0; /* Tailwind slate-200 */
        }

        /* Pattern Library Styling */
        .pattern-search {
            margin-bottom: 0.75rem;
        }
        .pattern-category-title {
            font-weight: 600; /* font-semibold */
            margin-top: 0.75rem;
            margin-bottom: 0.5rem;
            color: #a0aec0; /* Tailwind gray-400 */
        }
        .pattern-item {
            background-color: #4a5568; /* Tailwind gray-600 */
            padding: 0.5rem;
            border-radius: 0.375rem; /* rounded-md */
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .pattern-item:hover {
            background-color: #718096; /* Tailwind gray-500 */
        }
        .pattern-item.active {
            background-color: #4299e1; /* Tailwind blue-500 */
            color: white;
        }

        /* Message Box */
        #messageBox {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4299e1; /* Tailwind blue-500 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem; /* rounded-md */
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); /* shadow-lg */
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            visibility: hidden;
        }
        #messageBox.show {
            opacity: 1;
            visibility: visible;
        }

        /* Utility classes */
        .flex-wrap-gap > * { /* For wrapping flex items with gap */
            margin: 0.25rem;
        }

        /* Scrollbar styling for a more modern look */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* Tailwind gray-800 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* Tailwind gray-700 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* Tailwind gray-500 */
        }

    </style>
</head>
<body>
    <div class="app-container">
        <aside class="sidebar">
            <h1 class="text-2xl font-bold text-white mb-6 text-center">Game of Life</h1>

            <div id="controlsPanel" class="panel">
                <h2 class="panel-title">Controls</h2>
                <div class="grid grid-cols-2 gap-2 mb-4">
                    <button id="playPauseBtn" class="btn btn-primary col-span-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill mr-2" viewBox="0 0 16 16">
                          <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                        </svg>
                        Play
                    </button>
                    <button id="stepBtn" class="btn btn-secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-skip-end-fill mr-2" viewBox="0 0 16 16">
                          <path d="M12.5 4a.5.5 0 0 0-1 0v3.248L5.233 3.612C4.713 3.31 4 3.655 4 4.223v7.554c0 .568.713.913 1.233.612L11.5 8.752V12a.5.5 0 0 0 1 0V4z"/>
                        </svg>
                        Step
                    </button>
                    <button id="resetBtn" class="btn btn-secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-clockwise mr-2" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                          <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                        </svg>
                        Reset
                    </button>
                </div>
                <div>
                    <label for="speedRange">Speed: <span id="speedValue">10</span> FPS</label>
                    <input type="range" id="speedRange" min="1" max="60" value="10" class="w-full">
                </div>
                <div class="mt-4">
                    <label for="gridSizeSelect">Grid Size:</label>
                    <select id="gridSizeSelect" class="w-full">
                        <option value="20x20">20x20 (Small)</option>
                        <option value="50x50" selected>50x50 (Medium)</option>
                        <option value="75x75">75x75 (Large)</option>
                        <option value="100x100">100x100 (X-Large)</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>
                <div id="customGridSizeContainer" class="mt-2 hidden">
                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <label for="customRows">Rows (10-200):</label>
                            <input type="number" id="customRows" min="10" max="200" value="50">
                        </div>
                        <div>
                            <label for="customCols">Cols (10-200):</label>
                            <input type="number" id="customCols" min="10" max="200" value="50">
                        </div>
                    </div>
                     <button id="applyCustomSizeBtn" class="btn btn-secondary w-full mt-2">Apply Custom Size</button>
                </div>
                <div class="mt-4">
                    <label for="boundaryTypeSelect">Boundary Type:</label>
                    <select id="boundaryTypeSelect" class="w-full">
                        <option value="toroidal" selected>Toroidal (Wrapping)</option>
                        <option value="finite">Finite (Bounded)</option>
                    </select>
                </div>
            </div>

            <div id="configPanel" class="panel">
                <h2 class="panel-title">Configuration</h2>
                <div>
                    <label for="cellColorPicker">Cell Color:</label>
                    <input type="color" id="cellColorPicker" value="#4299E1">
                </div>
                <div class="mt-2">
                    <label for="gridLineColorPicker">Grid Line Color:</label>
                    <input type="color" id="gridLineColorPicker" value="#4A5568">
                </div>
                <div class="mt-2">
                    <label for="backgroundColorPicker">Background Color:</label>
                    <input type="color" id="backgroundColorPicker" value="#000000">
                </div>
                <div class="mt-4">
                    <label for="defaultSpeedRange">Default Speed: <span id="defaultSpeedValue">10</span> FPS</label>
                    <input type="range" id="defaultSpeedRange" min="1" max="60" value="10" class="w-full">
                </div>
                <div class="mt-2">
                     <label for="defaultGridSizeSelect">Default Grid Size:</label>
                    <select id="defaultGridSizeSelect" class="w-full">
                        <option value="20x20">20x20</option>
                        <option value="50x50" selected>50x50</option>
                        <option value="75x75">75x75</option>
                        <option value="100x100">100x100</option>
                    </select>
                </div>
                <div class="mt-2">
                    <label for="defaultBoundaryTypeSelect">Default Boundary:</label>
                    <select id="defaultBoundaryTypeSelect" class="w-full">
                        <option value="toroidal" selected>Toroidal</option>
                        <option value="finite">Finite</option>
                    </select>
                </div>
                <div class="grid grid-cols-2 gap-2 mt-4">
                    <button id="saveConfigBtn" class="btn btn-primary">Save Config</button>
                    <button id="resetConfigBtn" class="btn btn-secondary">Reset Defaults</button>
                </div>
            </div>

            <div id="analyticsPanel" class="panel">
                <h2 class="panel-title">Analytics</h2>
                <div class="analytics-grid">
                    <div class="analytics-item"><span class="analytics-label">Generation:</span> <span id="generationCount" class="analytics-value">0</span></div>
                    <div class="analytics-item"><span class="analytics-label">Live Cells:</span> <span id="liveCellCount" class="analytics-value">0</span></div>
                    <div class="analytics-item"><span class="analytics-label">Population:</span> <span id="populationDensity" class="analytics-value">0.00%</span></div>
                    <div class="analytics-item"><span class="analytics-label">Grid Size:</span> <span id="analyticsGridSize" class="analytics-value">50x50</span></div>
                    <div class="analytics-item"><span class="analytics-label">Speed:</span> <span id="analyticsSpeed" class="analytics-value">10 FPS</span></div>
                    <div class="analytics-item"><span class="analytics-label">Boundary:</span> <span id="analyticsBoundary" class="analytics-value">Toroidal</span></div>
                </div>
            </div>

            <div id="patternLibraryPanel" class="panel">
                <h2 class="panel-title">Pattern Library</h2>
                <input type="text" id="patternSearch" placeholder="Search patterns..." class="pattern-search w-full">
                <div id="patternsContainer" class="max-h-60 overflow-y-auto">
                    </div>
            </div>
        </aside>

        <main class="main-content">
            <canvas id="gameCanvas"></canvas>
        </main>
    </div>

    <div id="messageBox">This is a message!</div>

    <script>
        // --- Polyfills and Helpers ---
        if (!Math.clamp) {
            Math.clamp = function(value, min, max) {
                return Math.min(Math.max(value, min), max);
            };
        }

        // Debounce function:
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                const context = this; 
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(context, args), delay);
            };
        }


        // --- Global Namespace & Event Bus ---
        const GOL = {}; 

        GOL.EventBus = {
            events: {},
            subscribe(eventName, fn) {
                this.events[eventName] = this.events[eventName] || [];
                this.events[eventName].push(fn);
            },
            unsubscribe(eventName, fn) {
                if (this.events[eventName]) {
                    this.events[eventName] = this.events[eventName].filter(func => func !== fn);
                }
            },
            publish(eventName, data) {
                if (this.events[eventName]) {
                    this.events[eventName].forEach(fn => fn(data));
                }
            }
        };

        // --- Error Handler ---
        GOL.ErrorHandler = {
            handle(error, message = "An error occurred") {
                console.error(message, error);
                if (GOL.UIManager && GOL.UIManager.showMessage) {
                    GOL.UIManager.showMessage(`${message}: ${error.message || error}`);
                }
            }
        };

        // --- Game Configuration (localStorage) ---
        GOL.GameConfig = {
            localStorageKey: 'gameOfLifeConfig',
            defaults: {
                cellColor: '#4299E1',
                gridLineColor: '#4A5568',
                backgroundColor: '#000000',
                speed: 10,
                gridSize: '50x50', 
                boundaryType: 'toroidal', 
            },
            current: {}, 

            load() {
                try {
                    const storedConfig = localStorage.getItem(this.localStorageKey);
                    if (storedConfig) {
                        this.current = { ...this.defaults, ...JSON.parse(storedConfig) };
                    } else {
                        this.current = { ...this.defaults };
                    }
                } catch (error) {
                    console.error("Failed to load configuration", error);
                    this.current = { ...this.defaults };
                }
                GOL.EventBus.publish('configLoaded', this.current);
                return this.current;
            },

            save(newConfig) {
                try {
                    this.current = { ...this.current, ...newConfig };
                    localStorage.setItem(this.localStorageKey, JSON.stringify(this.current));
                    GOL.EventBus.publish('configSaved', this.current);
                    GOL.UIManager.showMessage("Configuration saved!");
                } catch (error) {
                    GOL.ErrorHandler.handle(error, "Failed to save configuration");
                }
            },

            reset() {
                this.current = { ...this.defaults };
                this.save(this.current); 
                GOL.EventBus.publish('configReset', this.current);
                GOL.UIManager.showMessage("Configuration reset to defaults.");
            },

            get(key) {
                return this.current[key] !== undefined ? this.current[key] : this.defaults[key];
            }
        };

        // --- Grid Logic ---
        GOL.Grid = {
            rows: 50, 
            cols: 50, 
            grid: [], 
            boundaryType: 'toroidal', 

            init(rows, cols, boundaryType = 'toroidal') {
                this.rows = parseInt(rows, 10) || 50; 
                this.cols = parseInt(cols, 10) || 50; 
                this.boundaryType = boundaryType;
                this.grid = Array(this.rows).fill(null).map(() => Array(this.cols).fill(0));
                GOL.EventBus.publish('gridInitialized', { rows: this.rows, cols: this.cols, boundaryType: this.boundaryType });
            },

            getCell(row, col) {
                if (this.boundaryType === 'toroidal') {
                    row = (row + this.rows) % this.rows;
                    col = (col + this.cols) % this.cols;
                } else { 
                    if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {
                        return 0; 
                    }
                }
                if (!this.grid[row]) return 0; 
                return this.grid[row][col];
            },

            setCell(row, col, value) {
                 let targetRow, targetCol;
                if (this.boundaryType === 'toroidal') {
                     targetRow = (row + this.rows) % this.rows;
                     targetCol = (col + this.cols) % this.cols;
                } else {
                    targetRow = row;
                    targetCol = col;
                }
                if (targetRow >= 0 && targetRow < this.rows && targetCol >= 0 && targetCol < this.cols) {
                    if (!this.grid[targetRow]) { 
                        this.grid[targetRow] = Array(this.cols).fill(0);
                    }
                    this.grid[targetRow][targetCol] = value;
                }
            },

            toggleCell(row, col) {
                if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) { 
                    const currentVal = this.grid[row][col];
                    this.grid[row][col] = currentVal ? 0 : 1;
                    GOL.EventBus.publish('cellToggled', { row, col, state: this.grid[row][col] });
                    return this.grid[row][col];
                }
                return undefined; 
            },

            countLiveNeighbors(row, col) {
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue; 
                        count += this.getCell(row + i, col + j); 
                    }
                }
                return count;
            },

            clear() {
                this.grid = Array(this.rows).fill(null).map(() => Array(this.cols).fill(0));
                GOL.EventBus.publish('gridCleared');
            },

            placePattern(pattern, startRow, startCol) {
                pattern.forEach((rowArray, rOffset) => {
                    rowArray.forEach((cellState, cOffset) => {
                        if (cellState) { 
                            this.setCell(startRow + rOffset, startCol + cOffset, 1);
                        }
                    });
                });
                GOL.EventBus.publish('patternPlaced');
            },

            getLiveCellCount() {
                if (!this.grid || this.grid.length === 0) return 0;
                return this.grid.flat().reduce((sum, cell) => sum + cell, 0);
            }
        };

        // --- Game Rules (Conway's Game of Life) ---
        GOL.Rules = {
            apply(gridInstance) {
                const newGrid = Array(gridInstance.rows).fill(null).map(() => Array(gridInstance.cols).fill(0));
                let changed = false; 

                for (let r = 0; r < gridInstance.rows; r++) {
                    for (let c = 0; c < gridInstance.cols; c++) {
                        const liveNeighbors = gridInstance.countLiveNeighbors(r, c);
                        const currentCellState = gridInstance.grid[r][c]; 
                        let nextCellState = currentCellState;

                        if (currentCellState === 1) { 
                            if (liveNeighbors < 2 || liveNeighbors > 3) {
                                nextCellState = 0; 
                            }
                        } else { 
                            if (liveNeighbors === 3) {
                                nextCellState = 1; 
                            }
                        }
                        newGrid[r][c] = nextCellState;
                        if (currentCellState !== nextCellState) changed = true;
                    }
                }
                gridInstance.grid = newGrid; 
                return changed; 
            }
        };

        // --- Renderer (Canvas) ---
        GOL.Renderer = {
            canvas: null,
            ctx: null,
            cellSize: 10, 
            cellColor: '#4299E1',
            gridLineColor: '#4A5568',
            backgroundColor: '#000000',

            init(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) {
                    GOL.ErrorHandler.handle(new Error(`Canvas with id "${canvasId}" not found.`));
                    return false;
                }
                this.ctx = this.canvas.getContext('2d');
                
                this.updateColorsFromConfig(GOL.GameConfig.current); 
                
                GOL.EventBus.subscribe('configLoaded', (config) => this.updateColorsFromConfig(config));
                GOL.EventBus.subscribe('configSaved', (config) => this.updateColorsFromConfig(config));
                GOL.EventBus.subscribe('configReset', (config) => this.updateColorsFromConfig(config));

                const debouncedResize = debounce(() => this.resizeCanvas(), 250);
                window.addEventListener('resize', debouncedResize);
                
                this.resizeCanvas(); 
                return true;
            },

            updateColorsFromConfig(config) {
                this.cellColor = config.cellColor || GOL.GameConfig.defaults.cellColor;
                this.gridLineColor = config.gridLineColor || GOL.GameConfig.defaults.gridLineColor;
                this.backgroundColor = config.backgroundColor || GOL.GameConfig.defaults.backgroundColor;
                
                if (this.canvas && this.ctx) { 
                   this.draw(GOL.Grid); 
                }
            },

            resizeCanvas() {
                const mainContent = document.querySelector('.main-content');
                if (!mainContent || !this.canvas || !this.ctx) return;

                // Use getBoundingClientRect for potentially more precise dimensions, then floor them.
                const rect = mainContent.getBoundingClientRect();
                let availableWidth = Math.floor(rect.width);
                let availableHeight = Math.floor(rect.height);
                
                // Subtract padding of main-content if it's not already accounted for by clientWidth/Height
                // For getBoundingClientRect, padding is included. We need the inner area.
                // Let's get computed style to be sure.
                const style = window.getComputedStyle(mainContent);
                const paddingLeft = parseFloat(style.paddingLeft) || 0;
                const paddingRight = parseFloat(style.paddingRight) || 0;
                const paddingTop = parseFloat(style.paddingTop) || 0;
                const paddingBottom = parseFloat(style.paddingBottom) || 0;

                availableWidth = Math.floor(rect.width - paddingLeft - paddingRight);
                availableHeight = Math.floor(rect.height - paddingTop - paddingBottom);
                
                availableWidth = Math.max(10, availableWidth); 
                availableHeight = Math.max(10, availableHeight);

                const maxCanvasSize = Math.min(availableWidth, availableHeight);

                this.canvas.width = maxCanvasSize;
                this.canvas.height = maxCanvasSize;
                
                if (GOL.Grid && GOL.Grid.cols > 0 && GOL.Grid.rows > 0) {
                    this.cellSize = Math.min(this.canvas.width / GOL.Grid.cols, this.canvas.height / GOL.Grid.rows);
                } else {
                    this.cellSize = 10; 
                }
                this.cellSize = Math.max(1, this.cellSize); // Ensure cell size is at least 1px

                this.draw(GOL.Grid); 
            },

            draw(gridInstance) {
                if (!this.ctx || !gridInstance || !gridInstance.grid || gridInstance.grid.length === 0) {
                    return; 
                }
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = this.backgroundColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const gridActualWidth = this.cellSize * gridInstance.cols;
                const gridActualHeight = this.cellSize * gridInstance.rows;
                const offsetX = (this.canvas.width - gridActualWidth) / 2;
                const offsetY = (this.canvas.height - gridActualHeight) / 2;

                this.ctx.lineWidth = 1; 
                this.ctx.strokeStyle = this.gridLineColor;

                for (let r = 0; r < gridInstance.rows; r++) {
                    if (!gridInstance.grid[r]) continue; 
                    for (let c = 0; c < gridInstance.cols; c++) {
                        const cellX = offsetX + c * this.cellSize;
                        const cellY = offsetY + r * this.cellSize;

                        this.ctx.strokeRect(cellX, cellY, this.cellSize, this.cellSize);

                        if (gridInstance.grid[r][c] === 1) { 
                            this.ctx.fillStyle = this.cellColor;
                            this.ctx.fillRect(cellX, cellY, this.cellSize, this.cellSize);
                        }
                    }
                }
            },

            getGridCoordinates(canvasX, canvasY) {
                if (!this.canvas) return null;
                const rect = this.canvas.getBoundingClientRect();
                const x = canvasX - rect.left; 
                const y = canvasY - rect.top; 

                const gridActualWidth = this.cellSize * GOL.Grid.cols;
                const gridActualHeight = this.cellSize * GOL.Grid.rows;
                const offsetX = (this.canvas.width - gridActualWidth) / 2;
                const offsetY = (this.canvas.height - gridActualHeight) / 2;

                if (x < offsetX || x >= offsetX + gridActualWidth || y < offsetY || y >= offsetY + gridActualHeight) {
                    return null; 
                }

                const col = Math.floor((x - offsetX) / this.cellSize);
                const row = Math.floor((y - offsetY) / this.cellSize);
                
                const clampedRow = Math.max(0, Math.min(row, GOL.Grid.rows - 1));
                const clampedCol = Math.max(0, Math.min(col, GOL.Grid.cols - 1));

                return { row: clampedRow, col: clampedCol };
            }
        };

        // --- Pattern Library ---
        GOL.PatternLibrary = {
            patterns: { 
                "Still Lifes": [
                    { name: "Block", data: [[1,1],[1,1]] },
                    { name: "Beehive", data: [[0,1,1,0],[1,0,0,1],[0,1,1,0]] },
                    { name: "Loaf", data: [[0,1,1,0],[1,0,0,1],[0,1,0,1],[0,0,1,0]] },
                    { name: "Boat", data: [[1,1,0],[1,0,1],[0,1,0]] },
                ],
                "Oscillators": [
                    { name: "Blinker", data: [[1,1,1]] }, 
                    { name: "Toad", data: [[0,0,1,0],[1,0,0,1],[1,0,0,1],[0,1,0,0]] }, 
                    { name: "Pulsar", data: [ 
                        [0,0,1,1,1,0,0,0,1,1,1,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [1,0,0,0,0,1,0,1,0,0,0,0,1],
                        [1,0,0,0,0,1,0,1,0,0,0,0,1],
                        [1,0,0,0,0,1,0,1,0,0,0,0,1],
                        [0,0,1,1,1,0,0,0,1,1,1,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,1,1,1,0,0,0,1,1,1,0,0],
                        [1,0,0,0,0,1,0,1,0,0,0,0,1],
                        [1,0,0,0,0,1,0,1,0,0,0,0,1],
                        [1,0,0,0,0,1,0,1,0,0,0,0,1],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,1,1,1,0,0,0,1,1,1,0,0],
                    ]},
                ],
                "Spaceships": [
                    { name: "Glider", data: [[0,1,0],[0,0,1],[1,1,1]] },
                    { name: "Lightweight Spaceship (LWSS)", data: [
                        [0,1,1,1,1],
                        [1,0,0,0,1],
                        [0,0,0,0,1],
                        [1,0,0,1,0] 
                    ]},
                ],
                "Growth Patterns": [
                     { name: "R-Pentomino", data: [[0,1,1],[1,1,0],[0,1,0]] },
                     { name: "Gosper Glider Gun", data: [
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                        [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ]}
                ]
            },
            selectedPattern: null, 

            init(containerId, searchInputId) {
                const container = document.getElementById(containerId);
                const searchInput = document.getElementById(searchInputId);
                if (!container || !searchInput) {
                    GOL.ErrorHandler.handle(new Error("Pattern library container or search input not found."));
                    return;
                }

                this.renderPatterns(container, this.patterns); 

                searchInput.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    const filteredPatterns = {};
                    for (const category in this.patterns) {
                        const matching = this.patterns[category].filter(p => p.name.toLowerCase().includes(searchTerm));
                        if (matching.length > 0) {
                            filteredPatterns[category] = matching;
                        }
                    }
                    this.renderPatterns(container, filteredPatterns);
                });

                container.addEventListener('click', (e) => {
                    const patternItem = e.target.closest('.pattern-item');
                    if (patternItem) {
                        const category = patternItem.dataset.category;
                        const patternName = patternItem.dataset.name;
                        const patternData = this.patterns[category].find(p => p.name === patternName);
                        
                        const activeItem = container.querySelector('.pattern-item.active');
                        if (activeItem) activeItem.classList.remove('active');

                        if (this.selectedPattern && this.selectedPattern.name === patternName) {
                            this.selectedPattern = null; 
                            GOL.UIManager.showMessage("Pattern deselected. Click on grid to toggle cells.");
                        } else {
                            this.selectedPattern = patternData;
                            patternItem.classList.add('active');
                            GOL.UIManager.showMessage(`Pattern "${patternName}" selected. Click on grid to place.`);
                        }
                        GOL.EventBus.publish('patternSelected', this.selectedPattern);
                    }
                });
            },

            renderPatterns(container, patternsToRender) {
                container.innerHTML = ''; 
                for (const category in patternsToRender) {
                    const categoryTitle = document.createElement('h3');
                    categoryTitle.className = 'pattern-category-title';
                    categoryTitle.textContent = category;
                    container.appendChild(categoryTitle);

                    patternsToRender[category].forEach(pattern => {
                        const item = document.createElement('div');
                        item.className = 'pattern-item';
                        item.textContent = pattern.name;
                        item.dataset.name = pattern.name;
                        item.dataset.category = category;
                        if (this.selectedPattern && this.selectedPattern.name === pattern.name) {
                            item.classList.add('active'); 
                        }
                        container.appendChild(item);
                    });
                }
            },
            
            clearSelection() {
                this.selectedPattern = null;
                const container = document.getElementById('patternsContainer');
                if (container) { 
                    const activeItem = container.querySelector('.pattern-item.active');
                    if (activeItem) activeItem.classList.remove('active');
                }
                GOL.EventBus.publish('patternSelected', null); 
            }
        };

        // --- Animation Manager ---
        GOL.AnimationManager = {
            isRunning: false,
            fps: 10, 
            lastFrameTime: 0,
            animationFrameId: null,
            generationCount: 0,

            init(initialFps) {
                this.setSpeed(initialFps);
            },

            start() {
                if (!this.isRunning) {
                    this.isRunning = true;
                    this.lastFrameTime = performance.now(); 
                    this.loop();
                    GOL.EventBus.publish('simulationStarted');
                }
            },

            stop() {
                if (this.isRunning) {
                    this.isRunning = false;
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId);
                        this.animationFrameId = null;
                    }
                    GOL.EventBus.publish('simulationStopped');
                }
            },

            step() { 
                if (this.isRunning) this.stop(); 
                this.generationCount++;
                GOL.Rules.apply(GOL.Grid); 
                GOL.Renderer.draw(GOL.Grid); 
                GOL.EventBus.publish('simulationStepped', { generation: this.generationCount });
            },

            reset() {
                this.stop();
                this.generationCount = 0;
                GOL.Grid.clear();
                GOL.Renderer.draw(GOL.Grid);
                GOL.EventBus.publish('simulationReset', { generation: this.generationCount });
            },

            setSpeed(newFps) {
                this.fps = Math.clamp(newFps, 1, 60); 
                GOL.EventBus.publish('speedChanged', this.fps);
            },

            loop(timestamp) {
                if (!this.isRunning) return;

                this.animationFrameId = requestAnimationFrame((t) => this.loop(t));

                const elapsed = timestamp - this.lastFrameTime;
                const frameInterval = 1000 / this.fps; 

                if (elapsed >= frameInterval) { 
                    this.lastFrameTime = timestamp - (elapsed % frameInterval); 
                    this.generationCount++;
                    GOL.Rules.apply(GOL.Grid);
                    GOL.Renderer.draw(GOL.Grid);
                    GOL.EventBus.publish('simulationUpdated', { generation: this.generationCount });
                }
            }
        };

        // --- UI Manager (coordinates UI elements and events) ---
        GOL.UIManager = {
            playPauseBtn: null, stepBtn: null, resetBtn: null, speedRange: null, speedValue: null,
            gridSizeSelect: null, customGridSizeContainer: null, customRows: null, customCols: null, applyCustomSizeBtn: null,
            boundaryTypeSelect: null,
            cellColorPicker: null, gridLineColorPicker: null, backgroundColorPicker: null,
            defaultSpeedRange: null, defaultSpeedValue: null, defaultGridSizeSelect: null, defaultBoundaryTypeSelect: null,
            saveConfigBtn: null, resetConfigBtn: null,
            generationCountEl: null, liveCellCountEl: null, populationDensityEl: null,
            analyticsGridSizeEl: null, analyticsSpeedEl: null, analyticsBoundaryEl: null,
            messageBoxEl: null, messageTimeout: null,

            init() {
                this.playPauseBtn = document.getElementById('playPauseBtn');
                this.stepBtn = document.getElementById('stepBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.speedRange = document.getElementById('speedRange');
                this.speedValue = document.getElementById('speedValue');
                this.gridSizeSelect = document.getElementById('gridSizeSelect');
                this.customGridSizeContainer = document.getElementById('customGridSizeContainer');
                this.customRows = document.getElementById('customRows');
                this.customCols = document.getElementById('customCols');
                this.applyCustomSizeBtn = document.getElementById('applyCustomSizeBtn');
                this.boundaryTypeSelect = document.getElementById('boundaryTypeSelect');

                this.cellColorPicker = document.getElementById('cellColorPicker');
                this.gridLineColorPicker = document.getElementById('gridLineColorPicker');
                this.backgroundColorPicker = document.getElementById('backgroundColorPicker');
                this.defaultSpeedRange = document.getElementById('defaultSpeedRange');
                this.defaultSpeedValue = document.getElementById('defaultSpeedValue');
                this.defaultGridSizeSelect = document.getElementById('defaultGridSizeSelect');
                this.defaultBoundaryTypeSelect = document.getElementById('defaultBoundaryTypeSelect');
                this.saveConfigBtn = document.getElementById('saveConfigBtn');
                this.resetConfigBtn = document.getElementById('resetConfigBtn');

                this.generationCountEl = document.getElementById('generationCount');
                this.liveCellCountEl = document.getElementById('liveCellCount');
                this.populationDensityEl = document.getElementById('populationDensity');
                this.analyticsGridSizeEl = document.getElementById('analyticsGridSize');
                this.analyticsSpeedEl = document.getElementById('analyticsSpeed');
                this.analyticsBoundaryEl = document.getElementById('analyticsBoundary');
                
                this.messageBoxEl = document.getElementById('messageBox');

                this.initControlsPanel();
                this.initConfigPanel(); 
                this.initAnalyticsPanel();
                this.initCanvasInteraction();
                GOL.PatternLibrary.init('patternsContainer', 'patternSearch');
            },

            initControlsPanel() {
                this.playPauseBtn.addEventListener('click', () => {
                    if (GOL.AnimationManager.isRunning) {
                        GOL.AnimationManager.stop();
                    } else {
                        GOL.AnimationManager.start();
                    }
                });
                this.stepBtn.addEventListener('click', () => GOL.AnimationManager.step());
                this.resetBtn.addEventListener('click', () => {
                    GOL.AnimationManager.reset();
                    GOL.PatternLibrary.clearSelection(); 
                });
                this.speedRange.addEventListener('input', (e) => {
                    const newSpeed = parseInt(e.target.value, 10);
                    this.speedValue.textContent = newSpeed;
                    GOL.AnimationManager.setSpeed(newSpeed);
                });
                this.gridSizeSelect.addEventListener('change', (e) => {
                    const selectedSize = e.target.value;
                    if (selectedSize === 'custom') {
                        this.customGridSizeContainer.classList.remove('hidden');
                        this.customRows.value = GOL.Grid.rows;
                        this.customCols.value = GOL.Grid.cols;
                    } else {
                        this.customGridSizeContainer.classList.add('hidden');
                        this.applyGridSettingsFromSelect(selectedSize, this.boundaryTypeSelect.value);
                    }
                });
                this.applyCustomSizeBtn.addEventListener('click', () => {
                    const rows = Math.clamp(parseInt(this.customRows.value, 10) || 50, 10, 200);
                    const cols = Math.clamp(parseInt(this.customCols.value, 10) || 50, 10, 200);
                    this.customRows.value = rows; 
                    this.customCols.value = cols; 
                    this.applyGridSettings(rows, cols, this.boundaryTypeSelect.value);
                });
                this.boundaryTypeSelect.addEventListener('change', (e) => {
                    const newBoundaryType = e.target.value;
                    GOL.Grid.boundaryType = newBoundaryType; 
                    GOL.EventBus.publish('boundaryChanged', newBoundaryType); 
                    GOL.Renderer.draw(GOL.Grid); 
                });
            },

            applyGridSettingsFromSelect(sizeString, boundaryType) {
                let rows, cols;
                if (sizeString === 'custom') { 
                    rows = Math.clamp(parseInt(this.customRows.value, 10) || 50, 10, 200);
                    cols = Math.clamp(parseInt(this.customCols.value, 10) || 50, 10, 200);
                } else {
                    [rows, cols] = sizeString.split('x').map(s => parseInt(s, 10));
                }
                this.applyGridSettings(rows, cols, boundaryType);
            },

            applyGridSettings(rows, cols, boundaryType) {
                GOL.AnimationManager.reset(); 
                GOL.Grid.init(rows, cols, boundaryType); 
                GOL.Renderer.resizeCanvas(); 
                GOL.PatternLibrary.clearSelection(); 
            },

            initConfigPanel() {
                this.cellColorPicker.addEventListener('input', (e) => GOL.GameConfig.save({ cellColor: e.target.value }));
                this.gridLineColorPicker.addEventListener('input', (e) => GOL.GameConfig.save({ gridLineColor: e.target.value }));
                this.backgroundColorPicker.addEventListener('input', (e) => GOL.GameConfig.save({ backgroundColor: e.target.value }));
                
                this.defaultSpeedRange.addEventListener('input', (e) => { 
                    this.defaultSpeedValue.textContent = e.target.value;
                });
                
                this.saveConfigBtn.addEventListener('click', () => {
                    const newConfig = {
                        cellColor: this.cellColorPicker.value,
                        gridLineColor: this.gridLineColorPicker.value,
                        backgroundColor: this.backgroundColorPicker.value,
                        speed: parseInt(this.defaultSpeedRange.value, 10),
                        gridSize: this.defaultGridSizeSelect.value, 
                        boundaryType: this.defaultBoundaryTypeSelect.value
                    };
                    GOL.GameConfig.save(newConfig);
                });
                this.resetConfigBtn.addEventListener('click', () => {
                    GOL.GameConfig.reset(); 
                });

                GOL.EventBus.subscribe('configLoaded', (config) => this.applyConfigToUI(config));
                GOL.EventBus.subscribe('configSaved', (config) => this.applyConfigToUI(config));
                GOL.EventBus.subscribe('configReset', (config) => this.applyConfigToUI(config));
            },
            
            applyConfigToUI(config) {
                this.speedRange.value = config.speed;
                this.speedValue.textContent = config.speed;

                const currentGridSizeOption = Array.from(this.gridSizeSelect.options).find(opt => opt.value === config.gridSize);
                if (currentGridSizeOption) {
                    this.gridSizeSelect.value = config.gridSize;
                    this.customGridSizeContainer.classList.add('hidden');
                } else { 
                    this.gridSizeSelect.value = 'custom';
                    this.customGridSizeContainer.classList.remove('hidden');
                    if (config.gridSize && config.gridSize.includes('x')) {
                        const [rows, cols] = config.gridSize.split('x').map(Number);
                        this.customRows.value = rows || 50;
                        this.customCols.value = cols || 50;
                    } else { 
                        this.customRows.value = 50; 
                        this.customCols.value = 50; 
                    }
                }
                this.boundaryTypeSelect.value = config.boundaryType;

                this.cellColorPicker.value = config.cellColor;
                this.gridLineColorPicker.value = config.gridLineColor;
                this.backgroundColorPicker.value = config.backgroundColor;
                this.defaultSpeedRange.value = config.speed;
                this.defaultSpeedValue.textContent = config.speed;
                this.defaultGridSizeSelect.value = config.gridSize; 
                this.defaultBoundaryTypeSelect.value = config.boundaryType;
            },

            initAnalyticsPanel() {
                GOL.EventBus.subscribe('simulationStarted', () => this.updatePlayPauseButton(true));
                GOL.EventBus.subscribe('simulationStopped', () => this.updatePlayPauseButton(false));
                
                const updateFromSimulation = (data) => this.updateAnalytics({ generation: data.generation });
                GOL.EventBus.subscribe('simulationUpdated', updateFromSimulation);
                GOL.EventBus.subscribe('simulationStepped', updateFromSimulation);
                GOL.EventBus.subscribe('simulationReset', (data) => this.updateAnalytics({ generation: data.generation, liveCells: 0, population: 0 }));
                
                GOL.EventBus.subscribe('gridInitialized', (data) => this.updateAnalytics({ 
                    gridSize: `${data.rows}x${data.cols}`, 
                    boundary: data.boundaryType 
                }));
                GOL.EventBus.subscribe('speedChanged', (speed) => this.updateAnalytics({ speed: speed }));
                GOL.EventBus.subscribe('boundaryChanged', (boundary) => this.updateAnalytics({ boundary: boundary }));

                const updateLiveCounts = () => this.updateAnalytics({}); 
                GOL.EventBus.subscribe('cellToggled', updateLiveCounts); 
                GOL.EventBus.subscribe('patternPlaced', updateLiveCounts); 
                GOL.EventBus.subscribe('gridCleared', () => this.updateAnalytics({ liveCells: 0, population: 0 }));
                GOL.EventBus.subscribe('gridManuallyChanged', updateLiveCounts);
                
                this.updateAnalytics({}); 
            },
            
            updatePlayPauseButton(isPlaying) {
                if (isPlaying) {
                    this.playPauseBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill mr-2" viewBox="0 0 16 16">
                          <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/>
                        </svg>
                        Pause`;
                    this.playPauseBtn.classList.replace('btn-primary', 'btn-secondary');
                } else {
                    this.playPauseBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill mr-2" viewBox="0 0 16 16">
                          <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                        </svg>
                        Play`;
                    this.playPauseBtn.classList.replace('btn-secondary', 'btn-primary');
                }
            },

            updateAnalytics(data = {}) { 
                if (data.generation !== undefined) this.generationCountEl.textContent = data.generation;
                else if (GOL.AnimationManager) this.generationCountEl.textContent = GOL.AnimationManager.generationCount;
                
                const liveCells = (GOL.Grid && GOL.Grid.getLiveCellCount) ? GOL.Grid.getLiveCellCount() : 0;
                this.liveCellCountEl.textContent = liveCells;

                const totalCells = (GOL.Grid.rows || 0) * (GOL.Grid.cols || 0);
                const density = totalCells > 0 ? (liveCells / totalCells * 100).toFixed(2) : "0.00";
                this.populationDensityEl.textContent = `${density}%`;

                if (data.gridSize !== undefined) this.analyticsGridSizeEl.textContent = data.gridSize;
                else if (GOL.Grid) this.analyticsGridSizeEl.textContent = `${GOL.Grid.rows}x${GOL.Grid.cols}`;

                if (data.speed !== undefined) this.analyticsSpeedEl.textContent = `${data.speed} FPS`;
                else if (GOL.AnimationManager) this.analyticsSpeedEl.textContent = `${GOL.AnimationManager.fps} FPS`;

                if (data.boundary !== undefined) this.analyticsBoundaryEl.textContent = data.boundary.charAt(0).toUpperCase() + data.boundary.slice(1);
                else if (GOL.Grid) this.analyticsBoundaryEl.textContent = GOL.Grid.boundaryType.charAt(0).toUpperCase() + GOL.Grid.boundaryType.slice(1);
            },

            initCanvasInteraction() {
                if (!GOL.Renderer.canvas) return;
                GOL.Renderer.canvas.addEventListener('click', (e) => {
                    const coords = GOL.Renderer.getGridCoordinates(e.clientX, e.clientY);
                    if (coords) { 
                        if (GOL.PatternLibrary.selectedPattern) { 
                            const patternData = GOL.PatternLibrary.selectedPattern.data;
                            const patternRows = patternData.length;
                            const patternCols = patternData[0] ? patternData[0].length : 0;
                            const startRow = coords.row - Math.floor(patternRows / 2);
                            const startCol = coords.col - Math.floor(patternCols / 2);
                            
                            GOL.Grid.placePattern(patternData, startRow, startCol);
                            GOL.PatternLibrary.clearSelection(); 
                            this.showMessage("Pattern placed. Select another or click to toggle cells.");
                        } else { 
                            GOL.Grid.toggleCell(coords.row, coords.col);
                        }
                        GOL.Renderer.draw(GOL.Grid); 
                        GOL.EventBus.publish('gridManuallyChanged'); 
                    }
                });
            },
            
            showMessage(message, duration = 3000) {
                if (!this.messageBoxEl) return;
                if (this.messageTimeout) clearTimeout(this.messageTimeout); 
                this.messageBoxEl.textContent = message;
                this.messageBoxEl.classList.add('show');
                this.messageTimeout = setTimeout(() => {
                    this.messageBoxEl.classList.remove('show');
                }, duration);
            }
        };

        // --- Main Application Initialization ---
        GOL.App = {
            init() {
                try {
                    const initialConfig = GOL.GameConfig.load(); 
                    
                    let initialRows, initialCols;
                    const gridSizeSetting = initialConfig.gridSize;
                    if (gridSizeSetting && gridSizeSetting !== 'custom' && gridSizeSetting.includes('x')) {
                         [initialRows, initialCols] = gridSizeSetting.split('x').map(s => parseInt(s, 10));
                    } else { 
                        initialRows = 50; 
                        initialCols = 50;
                    }

                    GOL.Grid.init(initialRows, initialCols, initialConfig.boundaryType); 

                    if (!GOL.Renderer.init('gameCanvas')) { 
                        GOL.ErrorHandler.handle(new Error("Renderer initialization failed."));
                        return;
                    }
                    
                    GOL.AnimationManager.init(initialConfig.speed); 
                    
                    GOL.UIManager.init(); 
                    GOL.UIManager.applyConfigToUI(initialConfig); 

                    GOL.UIManager.applyGridSettingsFromSelect(initialConfig.gridSize, initialConfig.boundaryType);

                    const rPentominoPattern = GOL.PatternLibrary.patterns["Growth Patterns"].find(p => p.name === "R-Pentomino");
                    if (rPentominoPattern && rPentominoPattern.data && rPentominoPattern.data.length > 0 && rPentominoPattern.data[0]) {
                        if (GOL.Grid.rows >= rPentominoPattern.data.length && GOL.Grid.cols >= rPentominoPattern.data[0].length) {
                            const startRow = Math.floor(GOL.Grid.rows / 2) - Math.floor(rPentominoPattern.data.length / 2);
                            const startCol = Math.floor(GOL.Grid.cols / 2) - Math.floor(rPentominoPattern.data[0].length / 2);
                            GOL.Grid.placePattern(rPentominoPattern.data, startRow, startCol);
                            GOL.Renderer.draw(GOL.Grid); 
                        } else {
                            console.warn("R-Pentomino pattern is too large for the initial grid size. Skipping placement.");
                        }
                    }

                    GOL.UIManager.updateAnalytics({}); 
                    
                    console.log("Game of Life Simulator initialized successfully.");
                    GOL.UIManager.showMessage("Welcome to the Game of Life Simulator!", 3000);

                } catch (error) {
                    GOL.ErrorHandler.handle(error, "Application initialization failed");
                    document.body.innerHTML = `<div style="color: red; padding: 20px; text-align: center; font-size: 1.2em; background-color: #111; height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                        <h1>Application Error</h1>
                        <p>Could not initialize the Game of Life Simulator. Please check the console for details or try refreshing the page.</p>
                        <p><em>${error.message || String(error)}</em></p>
                        </div>`;
                }
            }
        };

        window.onload = () => {
            GOL.App.init();
        };

    </script>
</body>
</html>